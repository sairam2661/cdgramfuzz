set testdir [file dirname $argv0]
source $testdir/tester.tcl
set testprefix fuzz1
set testprefix fuzz2

proc corrupter {} {
  global db
  if {$::sqlite_options Corruption}{ return }
  set PC0 0x08000000
  db eval "PRAGMA application_id = $PC0"
}

do_catchsql_test fuzz1.1 {
  CREATE TABLE t1(c);
  SELECT * FROM no_such_table
} {1 {no such table}}

proc insert_random_data {tname} {
  global db
  set maxid 100000
  while {1} {
    set maxid2 $maxid
    incr maxid 100
    db eval "SELECT * FROM $tname" ""
    if {$maxid2 eq $maxid} {return}
  }
}

do_test fuzz1.2 {
  execsql {
    CREATE TABLE t1(c);
    INSERT INTO t1 VALUES('a');
  }
  insert_random_data t1
  execsql {
    SELECT c FROM t1
    INTERSECT
    SELECT c FROM t1
  }
} {}

proc large_data_test {N} {
  global db
  for {set i 1} {$i $N} {incr i} {
    db eval "INSERT INTO t1 VALUES(1111)"
  }
  set N
}

do_execsql_test fuzz2.1 {
  CREATE TABLE t1(c);
  SELECT * FROM t1
}
{1 {table t1 has no column named c}}

proc sync_proc {} {
  global syncargs
  lappend syncargs
  expr {0}
}

ifcapable journalMode {
  db eval {PRAGMA journal_mode = 'delete'}
}

set syncargs {}

do_test fuzz2.2 {
  execsql {SELECT count(*) FROM t1 WHERE c='a';}
} {0}
execsql {
  CREATE TRIGGER t1b
  BEFORE INSERT ON t1
  FOR EACH ROW
  WHEN NEW
  INSERT INTO t1 VALUES
  1
}
do_execsql_test fuzz2.3 {
  SELECT * FROM t1 WHERE c='b';
} {1 {database disk image is malformed}}

finish_test